/* A sample linker script for stm32f4. 
 Works for any stm32 by changing the startup file.
 This should work for other targets too by changing the memory areas.
 Other targets may have different special sections that are not mapped here. 
 
 Feel free to send your versions for other targets.
 */
 
SECTIONS {
  . = 0x08000000;   /* rom in stm32 starts here */
  
  .text : { 
        /* these are generated by the startup file in standard 
	   peripheral library by st 
	   Put your startup files here  */
  	stm32f4/startup/startup.o(.isr_vector)  /* vector table should be the first */
	stm32f4/startup/startup.o(.text.Reset_Handler)
	stm32f4/startup/startup.o(.text)
	
	/* the normal text sections */
	*(.text) *(.text.*)
	}
	
  text_end = . ;
  
  .rodata : {
  	*(.rodata)
	*(.rodata.*)
	}
	
  rodata_end = . ;

  /* c++ and d needs this in arm */
  .ARM.extab : { *(.ARM.extab*) }
   PROVIDE_HIDDEN(__exidx_start = . ) ;
  .ARM.exidx : { *(.ARM.exidx*) }
   PROVIDE_HIDDEN(__exidx_end = .);
  
  
  /* TLS! */
  
  _tlsstart = .;  /* this address we need in tls.d */
  
  .tdata : {
    *(.tdata .tdata.*  )
  } 
  .tbss : { 
    *(.tbss .tbss.*)  
    *(.tcommon) 
    _tlsend = .;  /* this is needed in tls.d */
             /* We take the address inside section because the ld manual
             section 3.10.5 says that ld can add orphan sections between output
             sections and address taken between sections may not be correct.
             Section 3.10.8 says that an address inside
             section is relative if the section is relocatable. A  relative
             address is converted to an absolute address when used outside
             the section. */        
  } 

  /* for some reason tlsend gets the end address of tdata. Tbss is mapped
  correctly and the section is saved into file but the pointer is
  not incremented. We would like to have just the opposite: the section
  should not be in the file but the pointer should be incremented.
  This is what is used now as a workaround: */
  . += SIZEOF(.tbss);  
  _tlsend = . ;

  .init_array :  /* this is needed by d */
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array))
    PROVIDE_HIDDEN (__init_array_end = .);
  }
  
  .got :  /* this is needed by d */
   { *(.got.plt) *(.got) *(.got*) }

  _sidata = . ;  /* save the current location */
  
   
  . = 0x20001000; /* the data area starts here */
  /* ram in stm32 starts at 2000 0000 but the bootloader overwrites 
    the first 4 k.  
    Data starts here at 2000 1000 so it is possible to investigate
    the data area with the bootloader.
    Can be changed to 2000 0000 if more ram is needed */
    
  .data : AT (_sidata) { /* data is mapped to the ram address but 
                         actually stored after the other segments in rom */  
  	_sdata = . ; 
	*(.data .data.*)
	_edata = . ;  /* we need sidata, sdata and edata in startup code 
                          where we copy the data from rom to ram */
	  } 
	  
  /* bss is mapped after data in ram. The old ld does not store this segment
     to the file at all but gold stores it */
  .bss : { _sbss = . ;
           *(.bss .bss.*)
	   *(COMMON)
	   _ebss = . ; /* sbss and ebss needed in startup code where
	                  the area must be zeroed */
	 } 
	 
  /* end of stack. This is stored in the vector table in stm32.
    This could be a fixed address but here it is related to the end of the
    data area. This way we get the biggest possible free memory. 
    In this configuration all memory after estack is free. */
  _estack = (. + 0x1000);  /* 4 k for now */

 /* This makes sure that we do not use more ram than we have.
    Now it is fixed at 64 k. Some stm32 have more, some have less ram.
    There should be enough space for tls and malloc area after this address */
  ASSERT(_estack < 0x20010000, "*** ERROR: too much ram used")

}


